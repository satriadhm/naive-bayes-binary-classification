# -*- coding: utf-8 -*-
"""NaiveBayesClassification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uV9cOLZFGY-XOidASdSvMJUT1WlUnprA
"""

import pandas as pd
from google.colab import files
import io

uploaded = files.upload()

data = io.BytesIO(uploaded["traindata.csv"])
df = pd.read_csv(data, sep = None, engine = 'python')
df

X = df.drop('y', axis = 1)
y = df.y
X = (X - X.min()) / (X.max() - X.min())

df = pd.concat([X,y], axis = 1)
df.head()

#mengambil quarter pertama untuk testing dan 3 quarter sisanya untuk training
fold_first_quarter = (df.iloc[0:74].reset_index(drop=True),              df.iloc[74:296].reset_index(drop=True))

#mengambil 50 persen data dengan menyilang masing-masing untuk training dan testing
fold_first_half = (pd.concat([df.iloc[0:74],df.iloc[148:222]]).reset_index(drop=True), pd.concat([df.iloc[74:148],df.iloc[222:296]]).reset_index(drop=True))
fold_second_half = (pd.concat([df.iloc[74:148],df.iloc[148:222]]).reset_index(drop=True), pd.concat([df.iloc[0:74],df.iloc[222:296]]).reset_index(drop=True))

#mengambil quarter akhir untuk testing dan quarter awal hingga quarter ke-tiga untuk training
fold_last_quarter = (df.iloc[0:222].reset_index(drop=True),           df.iloc[222:296].reset_index(drop=True))

#menghitung tingkat ketepatan model yang dibangun
def akurasi(y_pred,y_true):
    n = len(y_pred)
    benar = 0
    for i in range(n):
       if y_pred[i] == y_true[i]:
        benar += 1
    return benar /n * 100

def separate_by_class(df):
  splitted_df = {}
  for kelas in df.y.unique():
    splitted_df[kelas] = df[df.y == kelas].reset_index(drop=True)
  return splitted_df

separate_by_class(df)[0].head()

def summarize_data(df):
  return df.describe().loc[['mean', 'std','count']]

summarize_data(df)

def summarize_by_class(df):
  separated = separate_by_class(df)
  summaries = {}
  for kelas in separated:
      summaries[kelas] = summarize_data(separated[kelas])
  return summaries

summarize_by_class(df)

"""#Gaussian Equation"""

import math

def gaussian_equation(x,mean,std):
  exponen = math.exp(-((x-mean)**2/(2*std**2)))
  return ( 1 / (math.sqrt(2*math.pi) * std)) * exponen

gaussian_equation(1,1,1)

def calculation_probabilites_class(x, summaries):
  n = sum([summaries[kelas].loc['count'].y for kelas in summaries])
  probs = {}
  for kelas in summaries:
    probs[kelas] = summaries[kelas].loc['count'].y / n
    for col in summaries[kelas].columns[:-1]:
        mean, std, count = summaries[kelas][col]
        probs[kelas] *= gaussian_equation(x[col],mean,std)
  return probs

summaries = summarize_by_class(df)

calculation_probabilites_class(df.iloc[0],summaries)

def predict(train,test):
  preds = []
  summaries = summarize_by_class(train)
  for _,row in test.iterrows():
    probs = calculation_probabilites_class(row, summaries)
    preds.append(max(probs, key = probs.get))
  return preds

accurate = []

for fold in [fold_first_quarter, fold_first_half, fold_second_half, fold_last_quarter]:
    train, test = fold

    y_test = test.y

    # Add more print statements if needed
    y_preds = predict(train, test)

    accurate.append(akurasi(y_preds, y_test))

print(f'rata-rata akurasi = {sum(accurate) / len(accurate):.2f}%')